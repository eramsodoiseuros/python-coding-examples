# SHA512

The `encrypted message` will be a string of characters that represents the `SHA512 hash` of the original message.

SHA512 is a one-way encryption algorithm, which means that it is not possible to decrypt the message once it has been encrypted. The primary use of SHA512 is to verify the integrity of a message, rather than to encrypt it.

To verify the integrity of a message, you can encrypt the original message with SHA512 and compare the resulting hash to the hash of the message that you received. If the hashes match, you can be confident that the message has not been tampered with.

# SHA256

The `encrypted message` will be a string of characters that represents the `SHA256 hash` of the original message.

SHA256 is a one-way encryption algorithm, which means that it is not possible to decrypt the message once it has been encrypted. The primary use of SHA512 is to verify the integrity of a message, rather than to encrypt it.

To verify the integrity of a message, you can encrypt the original message with SHA256 and compare the resulting hash to the hash of the message that you received. If the hashes match, you can be confident that the message has not been tampered with.

# AES

The `base64 module` is used to encode the key as a URL-safe string, the `Fernet class` from the `cryptography.fernet module` is used to encrypt and decrypt the message with the `AES algorithm`, and the `PBKDF2HMAC class` from the `cryptography.hazmat.primitives.kdf.pbkdf2 module` is used to generate a random key using the `PBKDF2 algorithm`.
 
To generate a random key I use the `PBKDF2 algorithm` with a `password`, `salt`, and `number of iterations` specified. The `PBKDF2HMAC class` takes a hashes object as an argument to specify the hash algorithm to use (in this case, SHA256), a key length, a salt, and the number of iterations.

The `derive()` method of the `PBKDF2HMAC class` generates a key from the password and salt using the PBKDF2 algorithm. The key is generated by applying the `PBKDF2 function` to the password and salt, and iterating the process a specified number of times (specified by the iterations argument).

The `PBKDF2 function` is designed to be computationally expensive, which makes it difficult for attackers to guess the password by trying different combinations of characters. This makes `PBKDF2` a good choice for generating keys for use in encryption.

The `derive()` method takes the password as an argument and returns the generated key. The key is then encoded as a URL-safe string using the `base64.urlsafe_b64encode()` function.